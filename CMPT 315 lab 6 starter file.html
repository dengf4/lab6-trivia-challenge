<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lab 6 — Trivia Challenge (Starter, Ch 9–10)</title>

  <!--
    ======================================================
    CMPT 315 — Lab 6 Starter 
    ======================================================

    WHAT THIS APP DOES (big picture):
    - A player enters Name + Email (validated).
    - The app fetches multiple-choice trivia questions from Open Trivia DB (no API key).
    - The player answers all questions in ONE round.
    - The app shows a final score AND an Answer Review on the Result screen.
    - The app saves a BEST SCORE in localStorage (so it survives refresh).


    IMPORTANT:
    - Keep element IDs the same (btnStart, screenQuiz, apiErrorBox, etc.).
      The JavaScript uses document.getElementById() to locate elements.
	  
	- Use const by default for values that do not get reassigned 
	(e.g., DOM element references, configuration objects, fixed arrays). 
	Use let only for variables that need to change during execution 
	(e.g., loop counters, accumulating totals, values updated inside functions).
  -->
  <style>
    /* =========================
       Task F: Creative UX
       You may customize colors,
       fonts, and button styles.
       ========================= */
    body { font-family: Helvetica, sans-serif; margin:0; background:#140b20; color:#eef2ff; }
    main { max-width: 900px; margin: 0 auto; padding: 18px; }
    .card { background:#2b1c47; border:1px solid rgba(255,255,255,0.10); border-radius: 14px; padding: 16px; margin-bottom: 14px; }
    label { display:block; font-weight:700; margin-top: 10px; }
    input, select {
      width:100%; padding:10px; border-radius: 10px;
      border:1px solid rgba(255,255,255,0.18);
      background:#0f172a; color:#eef2ff;
    }
    button { padding:10px 14px; border-radius: 10px; border:0; font-weight:700; cursor:pointer;}
    button.primary { background:#7b25eb; color:white; }
    button.primary:hover { background:#9a4dff; transition: background 0.2s; }
    button.secondary { background:rgba(255,255,255,0.10); color:white; }
    button.secondary:hover { background:rgba(255, 255, 255, 0.212); transition: background 0.2s; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 720px){ .row { grid-template-columns: 1fr; } }
    .err { color:#fb7185; min-height: 18px; font-size: 0.9rem; }
    .pill { display:inline-block; padding:6px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,0.14); color: rgba(255,255,255,0.85); }
    .hidden { display:none !important; }
    .notice { padding: 10px; border-radius: 12px; border:1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.06); }
    .choices { display:grid; gap: 10px; margin-top: 10px; }
    .choiceBtn {
      text-align:left; width: 100%;
      background: rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      color:#eef2ff;
    }
    .choiceBtn:hover { border-color: rgba(255,255,255,0.25); }
    .topbar { display:flex; flex-wrap:wrap; gap: 10px; justify-content: space-between; align-items:center; }
    .brand { display:flex; align-items:center; gap:10px; }
    .brand-logo { width:40px; height:40px; border-radius:10px; }
  </style>
</head>

<body>
<main>
  <!-- ============================
       HEADER / BRAND AREA (Task F)
       ============================ -->
  <div class="topbar">
    <div class="brand">
      <img src="https://cdn.pixabay.com/photo/2024/03/02/05/40/ai-generated-8607612_1280.png" alt="Trivia Logo" class="brand-logo" title="Photo by omarsiddiqui39 from Pixabay" />
      <h1>Quiz Kitty Trivia</h1>
    </div>
    <span class="pill">Ch 9–10: DOM + Events + Async APIs + localStorage</span>
  </div>

  <!-- ============================
       SCREEN 1: START SCREEN
       ============================ -->
  <section class="card" id="screenStart">
    <h2>Start</h2>

    <div class="notice">
      <p><b>Goal:</b> Complete one trivia round and see your score.</p>
      <p><b>Storage:</b> Your best score is saved in <b>localStorage</b> (this browser only).</p>
    </div>

    <div class="row">
      <div>
        <label for="name">Name</label>
        <input id="name" placeholder="Your name" />
        <div class="err" id="errName"></div>
      </div>
      <div>
        <label for="email">Email</label>
        <input id="email" placeholder="you@example.com" />
        <div class="err" id="errEmail"></div>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="category">Category (optional)</label>
        <select id="category">
          <option value="">Any Category</option>
          <option value="18">Computers</option>
          <option value="17">Science & Nature</option>
          <option value="19">Mathematics</option>
          <option value="9">General Knowledge</option>
        </select>
      </div>
      <div>
        <!-- Task D: Difficulty selection -->
        <label for="mode">Difficulty</label>
        <select id="mode">
          <option value="easy">Easy</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard</option>
        </select>
      </div>
    </div>

    <div class="topbar" style="margin-top:12px;">
      <button class="primary" id="btnStart">Start Quiz</button>
      <button class="secondary" id="btnReset">Reset Best Score</button>
    </div>

    <div style="margin-top:12px;" class="notice" id="progressBox">
      Best score: not loaded yet…
    </div>
  </section>

  <!-- ============================
       SCREEN 2: QUIZ SCREEN
       ============================ -->
  <section class="card hidden" id="screenQuiz">
    <div class="topbar">
      <h2 id="quizTitle">Trivia Round</h2>
      <div>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Q: <b id="qNum">1</b>/<span id="qTotal">10</span></span>
      </div>
    </div>

    <div class="notice hidden" id="loadingBox">Loading questions…</div>
    <div class="notice hidden" id="apiErrorBox"></div>

    <div class="notice" id="questionText">Question will appear here…</div>
    <div class="choices" id="choices"></div>

    <div class="topbar" style="margin-top:12px;">
      <button class="secondary" id="btnQuit">Quit</button>
    </div>
  </section>

  <!-- ============================
       SCREEN 3: RESULT SCREEN
       ============================ -->
  <section class="card hidden" id="screenResult">
    <h2 id="resultTitle">Result</h2>
    <div class="notice" id="resultText"></div>

    <!-- Task E: Answer Review (displayed at end) -->
    <div class="notice" id="reviewBox" style="white-space: pre-wrap; margin-top: 10px;">
      Answer review will appear here…
    </div>

    <div class="topbar" style="margin-top:12px;">
      <button class="primary" id="btnPlayAgain">Play Again</button>
      <button class="secondary" id="btnHome">Home</button>
    </div>
  </section>
</main>

<script>
/*
  ======================================================
  LAB 6 — TRIVIA CHALLENGE 
  ======================================================

  COMPLETE THESE TODO ITEMS (Ch. 9–10):
  - TODO #1 validateStartForm()      (Ch 9)
  - TODO #2 loadProgress()          (Ch 10 localStorage)
  - TODO #3 saveProgress(obj)       (Ch 10 localStorage)
  - TODO #4 getToken()              (Ch 10 fetch + async/await)
  - TODO #5 fetchQuestions(cfg)     (Ch 10 fetch + response_code handling)

  
  - Task D: Difficulty selection
      * The Difficulty dropdown (id="mode") gives "easy", "medium", or "hard".
      * You must set ROUND.difficulty based on that selection before fetching questions.

  - Task E: Show Answer Review at the end
      * Save the user's chosen answer for each question.
      * On the Result screen, list each question with:
          - Your answer
          - Correct answer
          - A mark ✓ or ✗

  NOTE:
  - Use textContent when showing user data.

  Short-Answer Questions

  Why do we need async/await when using fetch()?

  Fetching from an API involves making an asynchronous request: it waits for a response from the server. 
  Async functions use the await keyword, which pauses the execution of the function until the promise is 
  resolved, allowing other processes to run/load while waiting for the response.

  What does OpenTDB response_code mean in your implementation? Explain 0 and 5.

  The response_code refers to the status of the API request. 0 indicates that the request was successful and 
  the data was returned from the API. 5 indicates a rate limit error which indicates that too many requests were 
  made in a short time period and that the client must wait before making more requests.

  What exactly is stored under STORAGE_KEY and why is JSON used?

  A JSON string representing an object that contains the player's best score, the total number of questions, 
  and the number of attempts made is stored under STORAGE_KEY. JSON is used as localStorage only stores strings.
  The JSON method stringify() converts the object into a string format for storage; JSON.parse() converts the 
  string back to an object when retrieving the data.

  Describe what happens from clicking Start Quiz until the first question is displayed (mention the functions involved).

  When the Start Quiz button is clicked, the async function runRoundFlow() is called, which validates the form 
  inputs using validateStartForm(). If the form is valid, it calls startFromForm(), which reads the form input values 
  into the state.player object. Then, it initializes the initial quiz state and display by calling the beginRound() and 
  showOnly() functions. Next, setLoading() displays a loading indicator while attempt is made to fetch a token using getToken() 
  if one is not already stored in state.token. When the token is fetched, fetchQuestions() is called to retrieve questions from 
  the OpenTDB API. If the request is successful, it converts the API data into an internal format, hides the loading indicator, 
  and calls renderQuestion() to display the first question on the quiz screen. Unresolved promises and network or API errors 
  are caught and displayed using setApiError().
*/

(function () {
  "use strict";

  // ------------------------------------------------------
  // Round configuration
  // ------------------------------------------------------
  var ROUND = { difficulty: "easy", amount: 10 };

  // Save best score in this browser (localStorage)
  var STORAGE_KEY = "lab6_trivia_best";

  // Open Trivia DB endpoints (no API key required)
  var API = {
    token: "https://opentdb.com/api_token.php?command=request",
    questionsUrl: function (amount, difficulty, category, token) {
      var p = new URLSearchParams();
      p.set("amount", String(amount));
      p.set("difficulty", difficulty);
      p.set("type", "multiple");
      if (category) { p.set("category", category); }
      if (token) { p.set("token", token); }
      return "https://opentdb.com/api.php?" + p.toString();
    }
  };

  function $(id) { return document.getElementById(id); }

  // Screens
  var screenStart  = $("screenStart");
  var screenQuiz   = $("screenQuiz");
  var screenResult = $("screenResult");

  // Inputs
  var nameInput      = $("name");
  var emailInput     = $("email");
  var categorySelect = $("category");
  var modeSelect     = $("mode");   // Difficulty dropdown: easy/medium/hard

  // Errors
  var errName  = $("errName");
  var errEmail = $("errEmail");

  // Buttons
  var btnStart     = $("btnStart");
  var btnReset     = $("btnReset");
  var btnQuit      = $("btnQuit");
  var btnPlayAgain = $("btnPlayAgain");
  var btnHome      = $("btnHome");

  // Progress UI
  var progressBox = $("progressBox");

  // Quiz UI
  var quizTitle    = $("quizTitle");
  var scoreEl      = $("score");
  var qNumEl       = $("qNum");
  var qTotalEl     = $("qTotal");
  var questionText = $("questionText");
  var choicesBox   = $("choices");

  // Loading + errors
  var loadingBox  = $("loadingBox");
  var apiErrorBox = $("apiErrorBox");

  // Result UI
  var resultTitle = $("resultTitle");
  var resultText  = $("resultText");
  var reviewBox   = $("reviewBox");

  // Runtime state
  var state = {
    player: { name: "", email: "", category: "", mode: "easy" },
    token: null,
    questions: [],
    idx: 0,
    score: 0
  };

  // Screen helpers
  function show(el) { el.classList.remove("hidden"); }
  function hide(el) { el.classList.add("hidden"); }

  function showOnly(which) {
    hide(screenStart);
    hide(screenQuiz);
    hide(screenResult);
    show(which);
  }

  function setLoading(on) {
    if (on) { show(loadingBox); }
    else { hide(loadingBox); }
  }

  function setApiError(msg) {
    if (!msg) {
      apiErrorBox.textContent = "";
      hide(apiErrorBox);
      return;
    }
    apiErrorBox.textContent = msg;
    show(apiErrorBox);
  }

  function decodeHTMLEntities(s) {
    var t = document.createElement("textarea");
    t.innerHTML = s;
    return t.value;
  }

  function shuffle(arr) {
    var a = arr.slice();
    var i, j, tmp;
    for (i = a.length - 1; i > 0; i--) {
      j = Math.floor(Math.random() * (i + 1));
      tmp = a[i];
      a[i] = a[j];
      a[j] = tmp;
    }
    return a;
  }

  // ======================================================
  // TODO #1 (Ch 9): Form validation
  // ======================================================
  function validateStartForm() {
    errName.textContent = "";
    errEmail.textContent = "";

    // TODO:
    // - Name: 2–30 characters after trim()
    // - Email: basic valid shape (example: a@b.com)
    // - Show errors in errName / errEmail
    // - Return true if valid else false

    let valid = true;
    const name = nameInput.value.trim();
    const email = emailInput.value.trim();
    if (name.length < 2 || name.length > 30) {
      errName.textContent = "Name must be 2-30 characters.";
      valid = false;
    }
    if (!isValidEmail(email)) {
      errEmail.textContent = "Email must follow a basic valid shape (example: a@b.com).";
      valid = false;
    }
    return valid;
  }

  function isValidEmail(emailAddress) {
    if (emailAddress.indexOf('@') <= 0) {
      return false;
    }
    if (emailAddress.lastIndexOf('.') <= emailAddress.indexOf('@') + 1) {
      return false;
    }
    if (emailAddress.lastIndexOf('.') >= emailAddress.length - 1) {
      return false;
    }
    return true;
  }

  // ======================================================
  // TODO #2 (Ch 10): Load best score from localStorage
  // ======================================================
  function loadProgress() {
    // TODO: implement robust load:
    // - Return default { bestScore: 0, bestTotal: 0, attempts: 0 } if missing/invalid
    const data = localStorage.getItem(STORAGE_KEY);
    if (data) {
      try {
        const obj = JSON.parse(data);
        if (typeof obj.bestScore === "number" && typeof obj.bestTotal === "number" && typeof obj.attempts === "number") {
          return obj;
        }
      } catch (e) {
        // ignore invalid json
      }
    }
    return { bestScore: 0, bestTotal: 0, attempts: 0 };
  }

  // ======================================================
  // TODO #3 (Ch 10): Save best score to localStorage
  // ======================================================
  function saveProgress(obj) {
    // TODO: JSON.stringify + localStorage.setItem(STORAGE_KEY, ...)
    const data = JSON.stringify(obj);
    localStorage.setItem(STORAGE_KEY, data);
  }

  // ======================================================
  // TODO #4 (Ch 10): Request a token from OpenTDB
  // ======================================================
  async function getToken() {
    // TODO:
    // - var res = await fetch(API.token)
    // - if (!res.ok) throw Error(...)
    // - var data = await res.json()
    // - if (!data.token) throw Error(...)
    // - return data.token

    const res = await fetch(API.token);
    if (!res.ok) {
      throw new Error("Could not fetch token (HTTP status: " + res.status + ").");
    }
    const data = await res.json();
    if (!data.token) {
      throw new Error("Token is missing.");
    }
    return data.token;
  }

  // ======================================================
  // TODO #5 (Ch 10): Fetch questions for the round
  // ======================================================
  async function fetchQuestions(cfg) {
    // TODO:
    // - build URL using API.questionsUrl(cfg.amount, cfg.difficulty, state.player.category, state.token)
    // - fetch + await json
    // - handle response_code:
    //   0 -> return results
    //   5 -> throw rate limit error
    //   else -> throw generic error
      const url = API.questionsUrl(cfg.amount, cfg.difficulty, state.player.category, state.token);
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error("Error fetching questions (HTTP status: " + res.status + ").");
      }
      const data = await res.json();
      if (data.response_code === 0) {
        return data.results;
      } else if (data.response_code === 5) {
        throw new Error("Rate limit error.");
      } else {
        throw new Error("Unknown error (response code: " + data.response_code + ").");
      }
    return [];
  }

  // Display best score summary on Start screen
  function renderBest() {
    var p = loadProgress();
    var bestScore = (p && typeof p.bestScore === "number") ? p.bestScore : 0;
    var bestTotal = (p && typeof p.bestTotal === "number") ? p.bestTotal : 0;
    var attempts  = (p && typeof p.attempts  === "number") ? p.attempts  : 0;

    if (bestTotal > 0) {
      progressBox.textContent = "Best score: " + bestScore + "/" + bestTotal + " • Attempts: " + attempts;
    } else {
      progressBox.textContent = "Best score: none yet • Attempts: " + attempts;
    }
  }

  // Copy inputs into state.player
  function startFromForm() {
    state.player.name = nameInput.value.trim();
    state.player.email = emailInput.value.trim();
    state.player.category = categorySelect.value;
    state.player.mode = modeSelect.value; // stores easy/medium/hard
  }

  function beginRound() {
    state.questions = [];
    state.idx = 0;
    state.score = 0;

    scoreEl.textContent = "0";
    qNumEl.textContent = "1";
    qTotalEl.textContent = String(ROUND.amount);
    setApiError(null);
  }

  function renderQuestion() {
    var q = state.questions[state.idx];

    // Show current difficulty in the title
    quizTitle.textContent = "Trivia Round (" + ROUND.difficulty + ")";

    qTotalEl.textContent = String(ROUND.amount);
    qNumEl.textContent = String(state.idx + 1);

    questionText.textContent = q.question;
    choicesBox.innerHTML = "";

    var i;
    for (i = 0; i < q.choices.length; i++) {
      (function (choiceText) {
        var btn = document.createElement("button");
        btn.className = "choiceBtn";
        btn.textContent = choiceText;

        btn.addEventListener("click", function () {
          handleAnswer(choiceText);
        });

        choicesBox.appendChild(btn);
      })(q.choices[i]);
    }
  }

  function handleAnswer(choiceText) {
    var q = state.questions[state.idx];

    // --------------------------------------------
    // Task E (Answer Review) — PARTIAL PROVIDED
    // --------------------------------------------
    // TODO (students): Save the user's choice on the question object.
    // Example:
    // q.userChoice = choiceText;
    q.userChoice = choiceText;

    if (choiceText === q.correct) {
      state.score = state.score + 1;
      scoreEl.textContent = String(state.score);
    }

    state.idx = state.idx + 1;

    if (state.idx >= ROUND.amount) {
      finishRound();
    } else {
      renderQuestion();
    }
  }

  function finishRound() {
    showOnly(screenResult);

    resultTitle.textContent = "Result";
    resultText.textContent = state.player.name + ", your score is " + state.score + "/" + ROUND.amount + ".";

    // --------------------------------------------
    // Task E (Answer Review) — PARTIAL PROVIDED
    // --------------------------------------------
    // We will build a multi-line string and show it in reviewBox.
    // TODO: Finish the lines that show:
    // - Your answer (qq.userChoice)
    // - Correct answer (qq.correct)
    // - A mark ✓ or ✗ depending on whether they match
    var lines = [];
    lines.push("Answer Review (Your answer vs Correct answer):");
    lines.push("");

    var i;
    for (i = 0; i < state.questions.length; i++) {
      var qq = state.questions[i];
      lines.push((i + 1) + ") " + qq.question);

      // TODO: Add these lines and any ✓/✗ marking you want.
      // HINT:
      //  yourAns = qq.userChoice
      //  ok = (yourAns === qq.correct)
      //  use lines.push to show ✓ or ✗

      const yourAns = qq.userChoice;
      const ok = (yourAns === qq.correct);
      lines.push("  Your answer: " + yourAns + (ok ? " ✓" : " ✗"));
      lines.push("  Correct answer: " + qq.correct);
      lines.push("");
    }

    // Show the review text on the page
    reviewBox.textContent = lines.join("\n");

    // Update best score in localStorage
    var p = loadProgress();
    var attempts = (p && typeof p.attempts === "number") ? p.attempts : 0;
    attempts = attempts + 1;

    var bestScore = (p && typeof p.bestScore === "number") ? p.bestScore : 0;
    var bestTotal = (p && typeof p.bestTotal === "number") ? p.bestTotal : 0;

    if (bestTotal === 0 || state.score > bestScore) {
      saveProgress({ bestScore: state.score, bestTotal: ROUND.amount, attempts: attempts });
    } else {
      saveProgress({ bestScore: bestScore, bestTotal: bestTotal, attempts: attempts });
    }

    renderBest();
  }

  async function runRoundFlow() {
    if (!validateStartForm()) { return; }

    startFromForm();

    // --------------------------------------------------
    // Task D (Difficulty selection) 
    // --------------------------------------------------
    // TODO : Set (ROUND.difficulty) based on the dropdown selection (state - player - mode).
    // The dropdown provides: "easy", "medium", or "hard"
    ROUND.difficulty = state.player.mode;


    beginRound();
    showOnly(screenQuiz);

    try {
      setLoading(true);

      if (!state.token) {
        state.token = await getToken();
      }

      var raw = await fetchQuestions(ROUND);

      // Normalize API data into internal format
      state.questions = [];
      var i;
      for (i = 0; i < raw.length; i++) {
        var item = raw[i];

        var correct = decodeHTMLEntities(item.correct_answer);

        var incorrect = [];
        var k;
        for (k = 0; k < item.incorrect_answers.length; k++) {
          incorrect.push(decodeHTMLEntities(item.incorrect_answers[k]));
        }

        var choices = shuffle([correct].concat(incorrect));

        state.questions.push({
          question: decodeHTMLEntities(item.question),
          correct: correct,
          choices: choices
        });
      }

      setLoading(false);
      renderQuestion();

    } catch (e) {
      setLoading(false);
      setApiError(e.message || "Network / API error.");
    }
  }

  // Event listeners
  btnStart.addEventListener("click", function () {
    runRoundFlow();
  });

  btnReset.addEventListener("click", function () {
    localStorage.removeItem(STORAGE_KEY);
    renderBest();
    alert("Best score reset.");
  });

  btnQuit.addEventListener("click", function () {
    showOnly(screenStart);
  });

  btnPlayAgain.addEventListener("click", function () {
    runRoundFlow();
  });

  btnHome.addEventListener("click", function () {
    showOnly(screenStart);
  });

  // Boot
  renderBest();
  showOnly(screenStart);

})();
</script>
</body>
</html>
